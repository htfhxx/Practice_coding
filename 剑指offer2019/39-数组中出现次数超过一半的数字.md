##### 题目描述
数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。


##### 代码实现
O(nlogn)复杂度的实现，排序得到的中位数就是满足条件的候选者(要判断是否不存在这个数)
```

class Solution {
public:
    int MoreThanHalfNum_Solution(vector<int> numbers) {
        if(numbers.empty()==true)
            return 0;
        int len=numbers.size();
        sort(numbers.begin(),numbers.end());
        int cnt=0;
        for(int i=0;i<len;i++)
            if(numbers[i]==numbers[len/2])
                cnt++;
        if(cnt>len/2)
            return numbers[len/2];
        else
            return 0;
    }
};

 ```     

如果有满足条件的数字a，每次找到两个不相同的数字抵消掉，最后剩下的肯定是a  
从第一个数字开始，cnt=1，找到相同的就cnt++，相当于需要多找一个抵消；找到不相同的就cnt--，相当于两个抵消。  
抵消掉之前所有数字的话，相当于后面的数字还是a最多，就需要重新开始了。  
担心最后的结果不应该是cnt=0的时候遍历的数字？  
重复的次数超过一半的话，一定有相邻的数字相同 or 最后一个是a。例如：baa、aba、aab
```
class Solution {
public:
    int MoreThanHalfNum_Solution(vector<int> numbers) {
        if(numbers.empty()==true)
            return 0;
        int len=numbers.size();
        
        int result=numbers[0];
        int cnt=0;
        for(int i=0;i<len;i++){
            if(cnt==0){
                result=numbers[i];
                cnt=1;
            }
            else{
                if(numbers[i]==result)
                    cnt++;
                else
                    cnt--;
            }
        }
        cnt=0;
        for(int i=0;i<len;i++)
            if(numbers[i]==result)
                cnt++;
        if(cnt>len/2)
            return result;
        else
            return 0;
    }
};


```